import os
from snakemake.io import expand
from scripts.helpers.send_email import send_email

include: "rules/filter_selected_TxIDs.smk"

include: "rules/get_gencode_annotation.smk"
include: "rules/get_TSSs.smk"
include: "rules/sort_TSSs.smk"
include: "rules/filter_TSSs.smk"

include: "rules/filter_counts_new.smk"

include: "rules/get_mappability.smk"
include: "rules/filter_mappability.smk"
include: "rules/filter_CpGs_by_mappability.smk"
include: "rules/sort_CpGs.smk"

include: "rules/get_K_closest_CpGs.smk"

include: "rules/filter_selected_TxIDs_second_round.smk"
include: "rules/unpack_RSE.smk"
include: "rules/xgb_input.smk"

include: "rules/train_models.smk"
include: "rules/generate_feature_heatmap.smk"

include: "rules/aggregate_models_output.smk"
include: "rules/extract_CpGs_from_output.smk"
include: "rules/generate_genome_tracks.smk"
include: "rules/plot_models_output.smk"

include: "rules/get_chrom_sizes.smk"
include: "rules/clean_chrom_sizes.smk"
include: "rules/slop_TSSs.smk"
include: "rules/generate_ini_file.smk"
#include: "rules/plot_genome_tracks.smk"
include: "rules/prepare_TSSs_to_plot_tracks.smk"

include: "rules/garbage_collector.smk"

sender = config["sender"][0]
app_password = config["app_password"][0]
recipients = config["recipients"]

assembly_codes = config["assembly_codes"]
gencode_versions = config["gencode_versions"]
tss_subsets = config["tss_subsets"]
sample_types = config["sample_types"]
distances = config["distances"]
min_CpGs = config["min_CpGs"]
leftCount_betas = config["leftCount_betas"]
rightCount_betas = config["rightCount_betas"]
minCount_exprs = config["minCount_exprs"]
minSamples_betas = config["minSamples_betas"]
minCovs = config["minCovs"]
minSamples_exprs = config["minSamples_exprs"]
importances = config["importances"]

use_TMRs = config["use_TMRs"][0]

rule all:
    input:
        expand(
            "results/plots/filtering/nCpGs/{assembly_code}_{sample_type}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}.pdf",
                assembly_code=assembly_codes,
                gencode_version=gencode_versions,
                tss_subset=tss_subsets,
                distance=distances,
                min_CpG = min_CpGs,
                sample_type=sample_types,
                minCount_expr=minCount_exprs,
                minSamples_expr=minSamples_exprs
        ),
        expand(
            "results/plots/ML/hyper/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}.pdf",
                assembly_code=assembly_codes,
                gencode_version=gencode_versions,
                tss_subset=tss_subsets,
                distance=distances,
                min_CpG = min_CpGs,
                sample_type=sample_types,
                leftCount_beta = leftCount_betas,
                rightCount_beta = rightCount_betas,
                minSamples_beta = minSamples_betas,
                minCov = minCovs,
                minCount_expr=minCount_exprs,
                minSamples_expr=minSamples_exprs
            ),
        expand(
            "results/checks/heatmap/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}",
                assembly_code=assembly_codes,
                gencode_version=gencode_versions,
                tss_subset=tss_subsets,
                distance=distances,
                min_CpG = min_CpGs,
                sample_type=sample_types,
                leftCount_beta = leftCount_betas,
                rightCount_beta = rightCount_betas,
                minSamples_beta = minSamples_betas,
                minCov = minCovs,
                minCount_expr=minCount_exprs,
                minSamples_expr=minSamples_exprs        
            )


def txids_from_checkpoint(wildcards):
    """Return list of TxIDs from checkpoint output (cached)."""
    chk_output = checkpoints.filter_selected_TxIDs_second_round.get(
        assembly_code=wildcards.assembly_code,
        gencode_version=wildcards.gencode_version,
        tss_subset=wildcards.tss_subset,
        distance=wildcards.distance,
        min_CpG = wildcards.min_CpG,
        minCount_expr=wildcards.minCount_expr,
        minSamples_expr=wildcards.minSamples_expr
    ).output[0]

    with open(chk_output) as f:
        return [x.strip() for x in f]

def get_txid_xgb_input(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.xgb_input.output[0], TxID=txids, **wildcards)

def get_txid_train_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.train_models.output.plot_path, TxID=txids, **wildcards)

def get_txid_tracks_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.plot_genome_tracks.output, TxID=txids, **wildcards)

def get_txid_heatmap_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.generate_feature_heatmap.output, TxID=txids, **wildcards)

rule all_xgb_inputs:
    input:
        get_txid_xgb_input,
        "results/plots/filtering/nCpGs/{assembly_code}_{sample_type}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}.pdf"
    output:
        all_done_txid="results/checks/xgb/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

rule run_all_models:
    input:
        get_txid_train_outputs
    output:
        all_done_txid="results/checks/train/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

rule plot_tracks:
    input:
        get_txid_tracks_outputs
    output:
        all_done_txid="results/checks/tracks/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}_{importance}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

rule plot_heatmaps:
    input:
        get_txid_heatmap_outputs
    output:
        all_done_txid="results/checks/heatmap/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

wildcard_constraints:
    tss_subset="[a-z]+",
    distance = "[0-9]+",
    minSamples_beta = "[0-9]+",
    minCov = "[0-9]+",
    gencode_version="[0-9]+",
    minCount_expr="[0-9]+",
    assembly_code="hg\\d{2}",
    sample_type="[A-Z]",
    minCpG="[0-9]+",
    leftCount_beta="\\d+(\\.\\d+)?",
    rightCount_beta="\\d+(\\.\\d+)?",
    minSamples_expr="[0-9]+",
    K="[0-9]+",
    importance="[a-z]+"

onsuccess:

    dirs_to_clean = ["get_CpGs_by_TxID",
                    "get_transcriptome",
                    "subset_beta_matrix",
                    "generate_datasets",
                    "generate_genome_tracks",
                    "generate_feature_heatmap",
                    "extract_CpGs_from_output",
                    "train_models"]

    [
    os.system(
        f"for file in logs/{dir}/*; do cat $file >> logs/{dir}/{dir}_aggregated.log; done;"
        f"for file in logs/{dir}/*; do if [ $(basename $file) != {dir}_aggregated.log ]; then rm $file; fi  done;"
    )
    for dir in dirs_to_clean
]


    attachments = [f"logs/{path}/{elem}" for path in os.listdir("logs/") for elem in os.listdir(f"logs/{path}/")]
    send_email(subject = "Snakemake workflow - SUCCESS", 
            body = "The workflow completed successfully.",
            attachments=attachments,
            recipients=recipients, 
            sender=sender,
            app_password=app_password
    )

onerror:
    
    dirs_to_clean = ["get_CpGs_by_TxID",
                    "get_transcriptome",
                    "subset_beta_matrix",
                    "generate_datasets",
                    "generate_genome_tracks",
                    "generate_feature_heatmap",
                    "extract_CpGs_from_output",
                    "train_models"]

    [
    os.system(
        f"for file in logs/{dir}/*; do cat $file >> logs/{dir}/{dir}_aggregated.log; done;"
        f"for file in logs/{dir}/*; do if [ $(basename $file) != {dir}_aggregated.log ]; then rm $file; fi  done;"
    )
    for dir in dirs_to_clean
]


    attachments = [f"logs/{path}/{elem}" for path in os.listdir("logs/") for elem in os.listdir(f"logs/{path}/")]
    send_email(subject = "Snakemake workflow - FAILURE", 
            body = "Check the attachments for the failing logs.",
            attachments=attachments, 
            recipients=recipients, 
            sender=sender,
            app_password=app_password
    )